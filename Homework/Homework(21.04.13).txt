21. What is the purpose of 'this' keyword in java? 
this는 인스턴스의 자기 자신을 의미한다. 
this는 주로 필드와 메소드 또는 생성자의 매개변수가 동일할 때 
인스턴스 필드임을 명확히 하기 위해 사용한다. 
필드의 초기값인 매개변수와 필드의 변수명이 다를 경우는 this를 쓰지 않아도 된다. 
자기 자신의 생성자를 호출할 때 사용하는 키워드인 this()와는 다른 놈이다. 혼동하지 말자. 


22. Explain the concept of Inheritance? 
상속이란 부모 클래스가 가지고 있는 모든 것(생성자 제외)을 자식클래스가 물려받아 같이 공유하는 것이다. 
부모 클래스를 상위 클래스(superclass), 자식 클래스를 하위 클래스(subclass)라고 부른다. 
자바에서는 상속을 정의할 때 '확장(extends)한다'라고 부르는데, 
이는 부모 클래스에서 가지고 있는 추상적인 메소드를 자식 클래스에서 구체적인 메소드로 오버라이드 할 수 있기 때문이다. 
상속의 장점으로 코드가 중복되는 것을 막을 수 있고 공통적인 코드를 변경할 시 시간을 단축할 수 있다는 점이다. 


23. Which class in Java is superclass of every other class? 
상속되는 클래스를 부모 클래스라고 부르며 이를 곧 슈퍼클래스(super class)라고도 한다. 
서브클래스는 슈퍼클래스의 멤버와 메소드를 자기 것처럼 사용할 수 있다. 
슈퍼클래스에서 public이었다면 서브클래스에서도 public으로 일정하다. 
반대로 슈퍼클래스에서는 서브클래스의 멤버와 메소드를 사용할 수 없고, 
두 개 이상의 슈퍼 클래스로부터 상속 받을 수 없다. 
또한 슈퍼클래스에서 접근 지정자가 private으로 선언되어 있으면 이는 서브클래스에서 사용할 수 없다. 


24. Why Java does not support multiple inheritance? 
같은 이름의 메소드가 두 개의 상위 클래스에 모두 정의되어 있는 경우, 
어떤 메소드를 실행해야 될지 알 수가 없기 때문이다. 
이러한 식으로 충돌하는 경우를 방지하기 위해 다중 상속을 지원하지 않는다. 
반면 인터페이스는 다중상속이 가능한데, 인터페이스는 단지 선언만 해두기 때문에 다중상속이 되어도 전혀 문제되지 않는다.



ALGORITHM HOMEWORK(#27)
우리 학교에는 복도 불을 켜고 끄는 마부(Mabu)라는 사람이 있다. 전구마다 불을 켜고 끄는 스위치가 있다.
불이 꺼져 있을 때 스위치를 누르면 불이 켜지고 다시 스위치를 누르면 불이 꺼진다. 처음에는 모든 전구가
꺼져 있다. 마부라는 사람은 특이한 행동을 한다. 복도에 n개의 전구가 있으면, 복도를 n번 왕복한다. i번째
갈 때 그는 i로 나누어 떨어지는 위치에 있는 스위치만 누른다. 처음 위치로 돌아올 때는 아무 스위치도
건드리지 않는다. i번째 왕복은 (이런 이상한 행동을 하면서) 복도를 한 번 갔다가 오는 것으로 정의된다.
마지막 전구의 최종 상태를 알아내자. 과연 그 전구는 켜져 있을까 아니면 꺼져 있을까?
Input
복도에 있는 n번째 전구를 나타내는 숫자가 입력된다. 0은 입력의 끝을 의미하며 그 값은 처리하지 않는다.
Output
그 전구가 켜져 있으면 "yes"를, 꺼져 있으면 "no"를 출력한다. 테스트 케이스마다 한 줄에 하나씩 출력한다.


def light(n):
    # on(1)/off(0)
    # 전구 n개 = 왕복 n번 
    # i번째 왕복 ->  (n의 배수 % i) == 0
    # 마지막 전구....??? 
    
    while True:
        light = [] # 누른 전구 개수를 구하기 위한 변수
        if n == 0:
            break # 0은 처리하지 않는다 했으므로 예외처리. 결과값 없음 

        for i in range(1, n + 1): # 0은 ZeroDivisionError를 발생시키므로 1부터 실행
            if n % i == 0: # n이 i의 약수이면
                light.append(i) # light에 추가 
                
        print(light) # 테스트용 프린트.... 
        
        j = len(light) # 눌러진 전구의 수
        if j % 2 == 0: # 전구가 켜졌는지 꺼졌는지 확인 
            print("no") # off. 소수, 배수의 경우
            break
        else: 
            print("yes") # on. 제곱수의 경우 
            break

    
n = int(input("전구 수: "))
light(n)

# 값은 모범답안과 똑같이 나왔지만 제대로 푼 건지는 모르겠음.... 